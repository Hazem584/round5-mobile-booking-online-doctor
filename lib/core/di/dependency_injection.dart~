import 'package:flutter/foundation.dart';
import 'package:get_it/get_it.dart';
import 'package:dio/dio.dart';

import '../../features/home/data/datasource/doctor_remote_data_source.dart';
import '../../features/home/data/repo/doctor_repo_impl.dart';
import '../../features/notifications/data/repos/notifications_repository.dart';
import '../../features/notifications/logic/cubit/notifications_cubit.dart';

final getIt = GetIt.instance;

/// Main setup function that initializes all dependencies
Future<void> setupGetIt() async {
  try {
    if (kDebugMode) {
      print('üîß Setting up all dependencies...');
    }

    // Setup core dependencies first
    await _setupCoreDependencies();

    // Setup feature-specific dependencies
    await _setupDoctorDependencies();
    await _setupNotificationsDependencies();

    // Verify all dependencies are healthy
    if (_checkDependenciesHealth()) {
      if (kDebugMode) {
        print('‚úÖ All dependencies setup complete and healthy');
      }
    } else {
      if (kDebugMode) {
        print('‚ö†Ô∏è Some dependencies may have issues');
      }
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Critical error in dependency setup: $e');
    }
    await _setupFallbackDependencies();
  }
}

/// Setup core dependencies (Dio, etc.)
Future<void> _setupCoreDependencies() async {
  try {
    // Register Dio instance (if not already registered)
    if (!getIt.isRegistered<Dio>()) {
      getIt.registerLazySingleton<Dio>(() {
        final dio = Dio();

        // Configure Dio for performance and reliability
        dio.options.connectTimeout = const Duration(seconds: 10);
        dio.options.receiveTimeout = const Duration(seconds: 10);
        dio.options.sendTimeout = const Duration(seconds: 10);
        dio.options.baseUrl =
            'https://your-api-base-url.com/api/'; // Add your base URL

        // Add logging interceptor only in debug mode
        if (kDebugMode) {
          dio.interceptors.add(
            LogInterceptor(
              requestBody: true,
              responseBody: true,
              requestHeader: true,
              responseHeader: false,
              error: true,
              logPrint: (obj) {
                print('üåê HTTP: $obj');
              },
            ),
          );
        }

        // Add error handling interceptor
        dio.interceptors.add(
          InterceptorsWrapper(
            onRequest: (options, handler) {
              // Add your token here if available
              // final token = getTokenFromSecureStorage();
              // if (token != null) {
              //   options.headers['Authorization'] = 'Bearer $token';
              // }
              options.headers['Content-Type'] = 'application/json';
              options.headers['Accept'] = 'application/json';
              handler.next(options);
            },
            onResponse: (response, handler) {
              handler.next(response);
            },
            onError: (error, handler) {
              _handleDioError(error);
              handler.next(error);
            },
          ),
        );

        if (kDebugMode) {
          print('‚úÖ Dio configured successfully');
        }
        return dio;
      });
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Error setting up core dependencies: $e');
    }
  }
}

/// Setup doctor-related dependencies
Future<void> _setupDoctorDependencies() async {
  try {
    if (kDebugMode) {
      print('üîß Setting up doctor dependencies...');
    }

    // Uncomment and modify these lines based on your actual classes
    
    if (!getIt.isRegistered<DoctorRemoteDataSource>()) {
      getIt.registerLazySingleton<DoctorRemoteDataSource>(
        () => DoctorsRemoteDataSourceImpl(),
      );
    }

    if (!getIt.isRegistered<DoctorRepo>()) {
      getIt.registerLazySingleton<DoctorRepo>(
        () => DoctorRepoImpl(doctorRemoteDataSource: getIt<DoctorRemoteDataSource>()),
      );
    }
    

    if (kDebugMode) {
      print('‚úÖ Doctor dependencies setup complete');
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Error setting up doctor dependencies: $e');
    }
  }
}

/// Setup notifications dependencies
Future<void> _setupNotificationsDependencies() async {
  try {
    if (kDebugMode) {
      print('üîß Setting up notifications dependencies...');
    }

    // Register Mock Repository with error handling
    if (!getIt.isRegistered<MockNotificationsRepository>()) {
      getIt.registerLazySingleton<MockNotificationsRepository>(() {
        try {
          final repository = MockNotificationsRepository(dio: getIt<Dio>());
          if (kDebugMode) {
            print('‚úÖ MockNotificationsRepository registered');
          }
          return repository;
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Error creating MockNotificationsRepository: $e');
          }
          // Fallback: create repository without DI
          return MockNotificationsRepository();
        }
      });
    }

    // Register Cubit with error handling
    if (!getIt.isRegistered<NotificationsCubit>()) {
      getIt.registerFactory<NotificationsCubit>(() {
        try {
          final cubit = NotificationsCubit(
            getIt<MockNotificationsRepository>(),
          );
          if (kDebugMode) {
            print('‚úÖ NotificationsCubit registered');
          }
          return cubit;
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Error creating NotificationsCubit: $e');
          }
          // Fallback: create cubit with new repository
          return NotificationsCubit(MockNotificationsRepository());
        }
      });
    }

    if (kDebugMode) {
      print('‚úÖ Notifications dependencies setup complete');
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Error setting up notifications dependencies: $e');
    }
  }
}

/// Handle Dio errors consistently
void _handleDioError(DioException error) {
  if (kDebugMode) {
    switch (error.response?.statusCode) {
      case 401:
        print('üîê Unauthorized access - token may be expired');
        break;
      case 403:
        print('üö´ Forbidden access');
        break;
      case 404:
        print('üîç Endpoint not found');
        break;
      case 500:
        print('üî• Server error');
        break;
      default:
        if (error.type == DioExceptionType.connectionTimeout ||
            error.type == DioExceptionType.receiveTimeout) {
          print('‚è∞ Request timeout');
        } else {
          print('üåê Network error: ${error.message}');
        }
    }
  }
}

/// Emergency fallback setup
Future<void> _setupFallbackDependencies() async {
  try {
    if (kDebugMode) {
      print('üîß Setting up fallback dependencies...');
    }

    // Clear any existing problematic registrations
    _clearRegistrations();

    // Register simple fallback instances
    if (!getIt.isRegistered<MockNotificationsRepository>()) {
      getIt.registerLazySingleton<MockNotificationsRepository>(
        () => MockNotificationsRepository(),
      );
    }

    if (!getIt.isRegistered<NotificationsCubit>()) {
      getIt.registerFactory<NotificationsCubit>(
        () => NotificationsCubit(getIt<MockNotificationsRepository>()),
      );
    }

    if (kDebugMode) {
      print('‚úÖ Fallback dependencies setup complete');
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Critical error in fallback setup: $e');
    }
  }
}

/// Clear existing registrations safely
void _clearRegistrations() {
  try {
    final registrationsToRemove = [
      MockNotificationsRepository,
      NotificationsCubit,
      // Add other types as needed
    ];

    for (final type in registrationsToRemove) {
      if (getIt.isRegistered(instance: type)) {
        getIt.unregister(instance: type);
      }
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ö†Ô∏è Error clearing registrations: $e');
    }
  }
}

/// Check if all dependencies are properly registered
bool _checkDependenciesHealth() {
  try {
    final hasNotificationRepository = getIt
        .isRegistered<MockNotificationsRepository>();
    final hasNotificationCubit = getIt.isRegistered<NotificationsCubit>();
    // final hasDoctorRepo = getIt.isRegistered<DoctorRepo>();
    // final hasDoctorDataSource = getIt.isRegistered<DoctorRemoteDataSource>();

    if (kDebugMode) {
      print('ü©∫ Dependencies health check:');
      print(
        '   Notification Repository: ${hasNotificationRepository ? "‚úÖ" : "‚ùå"}',
      );
      print('   Notification Cubit: ${hasNotificationCubit ? "‚úÖ" : "‚ùå"}');
      // print('   Doctor Repository: ${hasDoctorRepo ? "‚úÖ" : "‚ùå"}');
      // print('   Doctor DataSource: ${hasDoctorDataSource ? "‚úÖ" : "‚ùå"}');
    }

    return hasNotificationRepository && hasNotificationCubit;
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Error checking dependencies health: $e');
    }
    return false;
  }
}

/// Helper function to reset all dependencies (for testing)
Future<void> resetAllDependencies() async {
  try {
    if (kDebugMode) {
      print('üîÑ Resetting all dependencies...');
    }

    await getIt.reset();
    await setupGetIt();

    if (kDebugMode) {
      print('‚úÖ All dependencies reset complete');
    }
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Error resetting dependencies: $e');
    }
  }
}

/// Get dependency info for debugging
Map<String, bool> getDependencyInfo() {
  return {
    'Dio': getIt.isRegistered<Dio>(),
    'NotificationRepository': getIt.isRegistered<MockNotificationsRepository>(),
    'NotificationCubit': getIt.isRegistered<NotificationsCubit>(),
    // 'DoctorRepo': getIt.isRegistered<DoctorRepo>(),
    // 'DoctorDataSource': getIt.isRegistered<DoctorRemoteDataSource>(),
  };
}
